\documentclass[a4peper, 12pt, titlepage, finall]{extreport}

%различные пакеты

\usepackage[T1, T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage[backend=bibtex]{biblatex}
\usepackage{csquotes}
\usepackage{tikz}
\usepackage{geometry}
\usepackage{indentfirst}
\usepackage{fontspec}
\usepackage{graphicx}
\usepackage{array}
\graphicspath{{./images/}}

\usetikzlibrary{positioning, arrows}

\geometry{a4paper, left = 15mm, top = 10mm, bottom = 15mm, right = 15mm}
\bibliography{report}
\setmainfont{Spectral Light}%{Times New Roman}
%\setmonofont{Courier New}
\setcounter{secnumdepth}{0}
%\setcounter{tocdepth}{3}
\nocite{*}
\begin{document}
\begin{center}
    {\large \bf «Исследование применимости алгоритмов сжатия к таблицам потоков в сетевом процессоре RuNPU»}
\end{center}
        \begin{flushright}
            {Никифоров Никита Игоревич, 421 группа}\\
            {Научный руководитель:\\доцент, к.ф.-м.н. Волканов Дмитрий Юрьевич}
        \end{flushright}
    \section{Введение}
        \if 0
        В данной работе рассматривается архитектура сетевого процессорного устройства (СПУ), в которой используется конвейерная архитектура.
        Конвейер состоит из последовательных вычислительных блоков, в каждом из которых находится независимое устройство памяти.
        В памяти вычислительного блока хранится программа классификации пакетов. Современные таблицы потоков занимают
        до нескольких десятков мегабайтов памяти \cite{rottenstreich2016optimal}.
        В связи с малым объёмом памяти внутри одного вычислительного блока $-$ 64 Кб, 
        необходимо провести исследование существующих алгоритмов сжатия данных, и предложить их адаптацию для использования 
        в рассматриваемом СПУ.
        \fi
        В настоящее время активно развиваются технологии программно-конфигурируемых сетей (ПКС)~\cite{smelopen}. Для работы ПКС требуются высокопроизводительные коммутаторы, 
        которые выполняют функцию передачи данных. Возникает задача разработки программируемого сетевого процессорного устройства (СПУ),
        являющегося основным функциональным элементом коммутаторов.

        В работе рассматривается коммутатор функционирующий под управлением протокола\\ OpenFlow.
        Правила обработки пакетов в котором представляются в виде таблицы потоков, групповые таблицы рассматриваться не будут.
        В СПУ таблицы потоков представляются в виде программы обработки заголовков сетевых пакетов.
        Для преобразования таблиц потоков в программу обработки заголовков сетевых пакетов используется транслятор табиц потоков.

        СПУ представляет из себя интегральную микросхему. В рассматриваемом СПУ (RuNPU) применяется конвейерная архитектура,
        а именно на каждый входной порт коммутатора $-$ СПУ содержит конвейер, состоящий из вычислительных блоков. Каждый вычислительный блок имеет доступ к 
        устройству памяти в котором хранится программа обработки заголовков сетевых пакетов. Рассматриваемый СПУ имеет ограниченный объём доступной
        памяти, для хранения программы обработки заголовков сетевых пакетов.
        Современные таблицы потоков занимают до нескольких десятков мегабайтов памяти \cite{rottenstreich2016optimal}. Поэтому возникает задача сжатия таблиц потоков,
        для использования рассматриваемого СПУ в коммутаторах ПКС.

        В рамках работы проведён обзор существующих алгоритмов сжатия, в котором были учтены следующие ограничения рассматриваемого СПУ:
        необходимость использования сжатых таблиц потоков без декомпрессии, ограниченный объём памяти на конвейерах СПУ. Критериями в обзоре
        были выбраны: возможность использования сжатых таблиц потоков без декомпрессии, оценка степени сжатия, необходимость использования внешней памяти
        для работы алгоритмов сжатия. На основе обзора был выбран алгоритм оптимального кеширования, с использованием внешней памяти.
        
        Для проведения экспериментального исследования выбранный алгоритм был реализован в трансляторе таблиц потоков, также была добавлена поддержка внешней памяти в 
        эмулятор СПУ. Использование алгоритма оптимального кеширования позволило снизить объём затрачиваемой памяти СПУ.\\
        \newpage
    \if 0
    \section{Формальная постановка задачи}
        Введём формализацию OpenFlow таблиц.
        Упорядоченное множество всех рассматриваемых признаков в правилах обозначим \(I=\{m_1,m_2,\ldots,m_k\}\). 
        Каждый признак \(m_i\) из множества признаков \(I\) характеризуется битовой строкой, некоторой длины \(m_i \in \{0, 1, *\}^W_i\),
        в данном случае символ \(*\) обозначает любой бит. При этом, если \(\exists m_i^j \in m_i\), такое, что 
        \( m_i^j = *\), то для \( \forall m_i^k \), где \(k > j\), то \( m_i^k = *\). Длиной признака обозначим \(len(m_i) = W_i\)

        Представим таблицу потоков в виде множества правил \(R=\{r_1,r_2,\ldots,r_n\}\). С каждым правилом \(r_i\) связаны:
        \begin{itemize}
            \item номер \(i\);
            \item приоритет \(p_i\in \mathbb{Z_+}\);
            \item вектор значений признаков \(f_i=\{f_i^1,f_i^2,\ldots,f_i^k\}\), где \(f_i^j\) соответствует значению признака \(m_j\in I\). % и \(f_i^j\in D(m_j)\cup\{*\}\), \(j=\overline{1,k}\).
            \item Набор инструкций, \(A_i = \{a_1, a_2, \ldots, a_z\} \), которые определяют дальнейшие действия сетевого процессора над пакетом.
        \end{itemize}

        Будем говорить, что заголовок пакета и его метаданные с вектором значений признаков \(g=\{g^1,g^2,\ldots,g^k\}\) 
        соответствуют правилу \(r_i\in R\) с вектором значений признаков \(f_i=\{f_i^1,f_i^2,\ldots,f_i^k\}\) 
        и приоритетом \(p_i\) (правило \(r_i\in R\) идентифицирует пакет с вектором значений признаков \(g\)), если:

        \begin{enumerate}
            \item вектор значений признаков \(g\) соответствует вектору значений признаков \(f_i\), 
                то есть \(\forall g_i \in g\), \(len(g_i) = len(f_i)\). И \(\forall f_i^l^j \in f_i^l\), \(f_i^l^j \in \{*, g^l^j\}\), \(l=\overline{1,k}\);
            \item приоритет \(p_i\) максимален среди всех правил \(r_j\in R\), для которых \(g\) соответствует вектору значений признаков \(f_j\).
        \end{enumerate}

        Множество \(R\) также должно удовлетворять следующему ограничению. 
        Для любых двух правил \(r_i,r_j\in R,r_i\not= r_j\), если их вектора значений пересекаются, то есть существует набор значений признаков, 
        который соответствует векторам значений признаков обоих правил, то \(p_i\not= p_j\). 
        Например, правила с векторами значений признаков \(f_i=\{110, 011, 1*\}\) и \(f_j=\{11*, 011, 11\}\) должны иметь разный приоритет, 
        так как набор значений признаков \(g=\{110, 011, 11\}\) соответствует обоим правилам.

        Введём понятие аналогичности множеств \(R_1\) и \(R_2\).
        Множество \(R_1\) аналогично множеству \(R_2\), если для любого заголовка пакета, для которого существует идентифицурующее его правило \(r_i \in R_1\), 
        найдётся правило идентифицирующее его в множестве \(r_j \in R_2\), при этом \(A_i = A_j\).

        Необходимо разработать алгоритм сжатия таблиц потоков, который будет переводить исходное множество $-$ \(R_1\), соответствующее исходной таблице потоков, в
        новое множество \(R_2\), которое соответствует новой таблице потоков.
        \begin{enumerate}
            \item Множество \(R_1\) должно быть аналогично множеству \(R_2\).
            \item Мощность множества \(R_2\) должна быть меньше либо равно мощности множества \(R_1\).
        \end{enumerate}

        Введём операцию последнего значащего бита признака \(last(m_i) = j\), такое, что \(m_i^j \in \{0, 1\}\) и \(m_i^(^j^+^1^) = *\). 
        Назовём правила \(r_i \in R\) и \(r_j \in R\) похожими, 
        если для \(\forall u \in len(f_i)\) верно, что \(last(f_i^u) = last(f_j^u) = l\), при этом \(f_i^u^l \neq f_j^u^l\), и \(A_i = A_j\).
    \fi
    \begingroup
    \let\clearpage\relax
    \printbibliography
    \endgroup
\end{document}
